进程和线程：

1）进程是静态的，其实就是指开启的一个程序；而线程是动态的，是真正执行的单元，执行的过程。其实我们平时看到的进程，是线程在执行着，因为线程是作为进程的一个单元存在的。

2）同样作为基本的执行单元，线程是划分得比进程更小的执行单位。

3）每个进程都有一段专用的内存区域。与此相反，线程却共享内存单元（包括代码和数据），通过共享的内存单元来实现数据交换、实时通信与必要的同步操作。

1、创建线程的方式：

创建方式一：继承Thread

    1：定义一个类继承Thread

    2：覆盖Thread中的run方法（将线程运行的代码放入run方法中）。

    3：直接创建Thread的子类对象

    4：调用start方法（内部调用了线程的任务（run方法））；作用：启动线程，调用run方法

 

方式二：实现Runnable

    1：定义类实现Runnable接口

    2：覆盖Runnable接口中的run方法，将线程的任务代码封装到run中

    3：通过Thread类创建线程对象

4、并将Runnable接口的子类对象作为Thread类的构造函数参数进行传递

作为参数传递的原因是让线程对象明确要运行的run方法所属的对象。

区别：

       继承方式：线程代码放在Thread子类的run方法中

       实现方式：线程存放在接口的子类run方法中；避免了单继承的局限性，建议使用。

2、线程状态：

新建：start()

临时状态：具备cpu的执行资格，但是无执行权

运行状态：具备CPU的执行权，可执行

冻结状态：通过sleep或者wait使线程不具备执行资格，需要notify唤醒，并处于临时状态。

消亡状态：run方法结束或者中断了线程，使得线程死亡。

3、多线程安全问题：

多个线程共享同一数据，当某一线程执行多条语句时，其他线程也执行进来，导致数据在某一语句上被多次修改，执行到下一语句时，导致错误数据的产生。

因素：多个线程操作共享数据；多条语句操作同一数据

解决：

       原理：某一时间只让某一线程执行完操作共享数据的所有语句。

       办法：使用锁机制：synchronized或lock对象

4、线程的同步：

当两个或两个以上的线程需要共享资源，他们需要某种方法来确定资源在某一刻仅被一个线程占用，达到此目的的过程叫做同步（synchronization）。

同步代码块：synchronized(对象){}，将需要同步的代码放在大括号中，括号中的对象即为锁。

同步函数：放于函数上，修饰符之后，返回类型之前。

5、wait和sleep的区别：（执行权和锁区分）

wait：可指定等待的时间，不指定须由notify或notifyAll唤醒。

       线程会释放执行权，且释放锁。

sleep：必须制定睡眠的时间，时间到了自动处于临时（阻塞）状态。

       即使睡眠了，仍持有锁，不会释放执行权。

 

Android下 的进程与线程：

1、进程的生命周期：

1）、进程的创建及回收：

       进程是被系统创建的，当内存不足的时候，又会被系统回收

2）、进程的级别：

Foreground Process              前台进程

Visible Process              可视进程

Service Process             服务进程：可以提高级别的

Background Process       后台进程

Empty Process              空进程（无组件启动，做进程缓存使用，恢复速度快）

 

总结用的安全与不安全API

　　Hashtable-->HashMap

　　StringBuffer-->StringBuilder

　　线程安全就是为了在单们时间内某个线程操作的是同样的数据
